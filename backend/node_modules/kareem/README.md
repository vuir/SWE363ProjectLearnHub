# kareem

  [![Build Status](https://github.com/mongoosejs/kareem/actions/workflows/test.yml/badge.svg?branch=master)](https://github.com/mongoosejs/kareem/actions/workflows/test.yml)
  <!--[![Coverage Status](https://img.shields.io/coveralls/vkarpov15/kareem.svg)](https://coveralls.io/r/vkarpov15/kareem)-->

Re-imagined take on the [hooks](http://npmjs.org/package/hooks) module, meant to offer additional flexibility in allowing you to execute hooks whenever necessary, as opposed to simply wrapping a single function.

<<<<<<< HEAD
Named for the NBA's 2nd all-time leading scorer Kareem Abdul-Jabbar, known for his mastery of the [hook shot](http://en.wikipedia.org/wiki/Kareem_Abdul-Jabbar#Skyhook)

<img src="http://upload.wikimedia.org/wikipedia/commons/0/00/Kareem-Abdul-Jabbar_Lipofsky.jpg" width="220">

<!--DOCS START-->

=======
Named for the NBA's all-time leading scorer Kareem Abdul-Jabbar, known for his mastery of the [hook shot](http://en.wikipedia.org/wiki/Kareem_Abdul-Jabbar#Skyhook)

<img src="http://upload.wikimedia.org/wikipedia/commons/0/00/Kareem-Abdul-Jabbar_Lipofsky.jpg" width="220">

>>>>>>> main
# API

## pre hooks

Much like [hooks](https://npmjs.org/package/hooks), kareem lets you define
pre and post hooks: pre hooks are called before a given function executes.
Unlike hooks, kareem stores hooks and other internal state in a separate
object, rather than relying on inheritance. Furthermore, kareem exposes
an `execPre()` function that allows you to execute your pre hooks when
appropriate, giving you more fine-grained control over your function hooks.

<<<<<<< HEAD
### It runs without any hooks specified
=======

#### It runs without any hooks specified
>>>>>>> main

```javascript
hooks.execPre('cook', null, function() {
  // ...
});
```

<<<<<<< HEAD
### It runs basic serial pre hooks
=======
#### It runs basic serial pre hooks
>>>>>>> main

pre hook functions take one parameter, a "done" function that you execute
when your pre hook is finished.

<<<<<<< HEAD
```javascript
let count = 0;
=======

```javascript
var count = 0;
>>>>>>> main

hooks.pre('cook', function(done) {
  ++count;
  done();
});

hooks.execPre('cook', null, function() {
  assert.equal(1, count);
});
```

<<<<<<< HEAD
### It can run multiple pre hooks

```javascript
let count1 = 0;
let count2 = 0;
=======
#### It can run multipe pre hooks

```javascript
var count1 = 0;
var count2 = 0;
>>>>>>> main

hooks.pre('cook', function(done) {
  ++count1;
  done();
});

hooks.pre('cook', function(done) {
  ++count2;
  done();
});

hooks.execPre('cook', null, function() {
  assert.equal(1, count1);
  assert.equal(1, count2);
});
```

<<<<<<< HEAD
### It can run fully synchronous pre hooks
=======
#### It can run fully synchronous pre hooks
>>>>>>> main

If your pre hook function takes no parameters, its assumed to be
fully synchronous.

<<<<<<< HEAD
```javascript
let count1 = 0;
let count2 = 0;
=======

```javascript
var count1 = 0;
var count2 = 0;
>>>>>>> main

hooks.pre('cook', function() {
  ++count1;
});

hooks.pre('cook', function() {
  ++count2;
});

hooks.execPre('cook', null, function(error) {
  assert.equal(null, error);
  assert.equal(1, count1);
  assert.equal(1, count2);
});
```

<<<<<<< HEAD
### It properly attaches context to pre hooks

Pre save hook functions are bound to the second parameter to `execPre()`

=======
#### It properly attaches context to pre hooks

Pre save hook functions are bound to the second parameter to `execPre()`


>>>>>>> main
```javascript
hooks.pre('cook', function(done) {
  this.bacon = 3;
  done();
});

hooks.pre('cook', function(done) {
  this.eggs = 4;
  done();
});

<<<<<<< HEAD
const obj = { bacon: 0, eggs: 0 };
=======
var obj = { bacon: 0, eggs: 0 };
>>>>>>> main

// In the pre hooks, `this` will refer to `obj`
hooks.execPre('cook', obj, function(error) {
  assert.equal(null, error);
  assert.equal(3, obj.bacon);
  assert.equal(4, obj.eggs);
});
```

<<<<<<< HEAD
### It can execute parallel (async) pre hooks
=======
#### It can execute parallel (async) pre hooks
>>>>>>> main

Like the hooks module, you can declare "async" pre hooks - these take two
parameters, the functions `next()` and `done()`. `next()` passes control to
the next pre hook, but the underlying function won't be called until all
async pre hooks have called `done()`.

<<<<<<< HEAD
=======

>>>>>>> main
```javascript
hooks.pre('cook', true, function(next, done) {
  this.bacon = 3;
  next();
  setTimeout(function() {
    done();
  }, 5);
});

hooks.pre('cook', true, function(next, done) {
  next();
<<<<<<< HEAD
  const _this = this;
=======
  var _this = this;
>>>>>>> main
  setTimeout(function() {
    _this.eggs = 4;
    done();
  }, 10);
});

hooks.pre('cook', function(next) {
  this.waffles = false;
  next();
});

<<<<<<< HEAD
const obj = { bacon: 0, eggs: 0 };
=======
var obj = { bacon: 0, eggs: 0 };
>>>>>>> main

hooks.execPre('cook', obj, function() {
  assert.equal(3, obj.bacon);
  assert.equal(4, obj.eggs);
  assert.equal(false, obj.waffles);
});
```

<<<<<<< HEAD
### It supports returning a promise
=======
#### It supports returning a promise
>>>>>>> main

You can also return a promise from your pre hooks instead of calling
`next()`. When the returned promise resolves, kareem will kick off the
next middleware.

<<<<<<< HEAD
=======

>>>>>>> main
```javascript
hooks.pre('cook', function() {
  return new Promise(resolve => {
    setTimeout(() => {
      this.bacon = 3;
      resolve();
    }, 100);
  });
});

<<<<<<< HEAD
const obj = { bacon: 0 };
=======
var obj = { bacon: 0 };
>>>>>>> main

hooks.execPre('cook', obj, function() {
  assert.equal(3, obj.bacon);
});
```

## post hooks

<<<<<<< HEAD
### It runs without any hooks specified
=======
acquit:ignore:end

#### It runs without any hooks specified
>>>>>>> main

```javascript
hooks.execPost('cook', null, [1], function(error, eggs) {
  assert.ifError(error);
  assert.equal(1, eggs);
  done();
});
```

<<<<<<< HEAD
### It executes with parameters passed in
=======
#### It executes with parameters passed in
>>>>>>> main

```javascript
hooks.post('cook', function(eggs, bacon, callback) {
  assert.equal(1, eggs);
  assert.equal(2, bacon);
  callback();
});

hooks.execPost('cook', null, [1, 2], function(error, eggs, bacon) {
  assert.ifError(error);
  assert.equal(1, eggs);
  assert.equal(2, bacon);
});
```

<<<<<<< HEAD
### It can use synchronous post hooks

```javascript
const execed = {};
=======
#### It can use synchronous post hooks

```javascript
var execed = {};
>>>>>>> main

hooks.post('cook', function(eggs, bacon) {
  execed.first = true;
  assert.equal(1, eggs);
  assert.equal(2, bacon);
});

hooks.post('cook', function(eggs, bacon, callback) {
  execed.second = true;
  assert.equal(1, eggs);
  assert.equal(2, bacon);
  callback();
});

hooks.execPost('cook', null, [1, 2], function(error, eggs, bacon) {
  assert.ifError(error);
  assert.equal(2, Object.keys(execed).length);
  assert.ok(execed.first);
  assert.ok(execed.second);
  assert.equal(1, eggs);
  assert.equal(2, bacon);
});
```

<<<<<<< HEAD
### It supports returning a promise
=======
#### It supports returning a promise
>>>>>>> main

You can also return a promise from your post hooks instead of calling
`next()`. When the returned promise resolves, kareem will kick off the
next middleware.

<<<<<<< HEAD
```javascript
hooks.post('cook', function() {
=======

```javascript
hooks.post('cook', function(bacon) {
>>>>>>> main
  return new Promise(resolve => {
    setTimeout(() => {
      this.bacon = 3;
      resolve();
    }, 100);
  });
});

<<<<<<< HEAD
const obj = { bacon: 0 };
=======
var obj = { bacon: 0 };
>>>>>>> main

hooks.execPost('cook', obj, obj, function() {
  assert.equal(obj.bacon, 3);
});
```

## wrap()

<<<<<<< HEAD
### It wraps pre and post calls into one call
=======
acquit:ignore:end

#### It wraps pre and post calls into one call
>>>>>>> main

```javascript
hooks.pre('cook', true, function(next, done) {
  this.bacon = 3;
  next();
  setTimeout(function() {
    done();
  }, 5);
});

hooks.pre('cook', true, function(next, done) {
  next();
<<<<<<< HEAD
  const _this = this;
=======
  var _this = this;
>>>>>>> main
  setTimeout(function() {
    _this.eggs = 4;
    done();
  }, 10);
});

hooks.pre('cook', function(next) {
  this.waffles = false;
  next();
});

hooks.post('cook', function(obj) {
  obj.tofu = 'no';
});

<<<<<<< HEAD
const obj = { bacon: 0, eggs: 0 };

const args = [obj];
=======
var obj = { bacon: 0, eggs: 0 };

var args = [obj];
>>>>>>> main
args.push(function(error, result) {
  assert.ifError(error);
  assert.equal(null, error);
  assert.equal(3, obj.bacon);
  assert.equal(4, obj.eggs);
  assert.equal(false, obj.waffles);
  assert.equal('no', obj.tofu);

  assert.equal(obj, result);
});

hooks.wrap(
  'cook',
  function(o, callback) {
    assert.equal(3, obj.bacon);
    assert.equal(4, obj.eggs);
    assert.equal(false, obj.waffles);
    assert.equal(undefined, obj.tofu);
    callback(null, o);
  },
  obj,
  args);
```

## createWrapper()

<<<<<<< HEAD
### It wraps wrap() into a callable function
=======
#### It wraps wrap() into a callable function
>>>>>>> main

```javascript
hooks.pre('cook', true, function(next, done) {
  this.bacon = 3;
  next();
  setTimeout(function() {
    done();
  }, 5);
});

hooks.pre('cook', true, function(next, done) {
  next();
<<<<<<< HEAD
  const _this = this;
=======
  var _this = this;
>>>>>>> main
  setTimeout(function() {
    _this.eggs = 4;
    done();
  }, 10);
});

hooks.pre('cook', function(next) {
  this.waffles = false;
  next();
});

hooks.post('cook', function(obj) {
  obj.tofu = 'no';
});

<<<<<<< HEAD
const obj = { bacon: 0, eggs: 0 };

const cook = hooks.createWrapper(
=======
var obj = { bacon: 0, eggs: 0 };

var cook = hooks.createWrapper(
>>>>>>> main
  'cook',
  function(o, callback) {
    assert.equal(3, obj.bacon);
    assert.equal(4, obj.eggs);
    assert.equal(false, obj.waffles);
    assert.equal(undefined, obj.tofu);
    callback(null, o);
  },
  obj);

cook(obj, function(error, result) {
  assert.ifError(error);
  assert.equal(3, obj.bacon);
  assert.equal(4, obj.eggs);
  assert.equal(false, obj.waffles);
  assert.equal('no', obj.tofu);

  assert.equal(obj, result);
});
```

## clone()

<<<<<<< HEAD
### It clones a Kareem object

```javascript
const k1 = new Kareem();
k1.pre('cook', function() {});
k1.post('cook', function() {});

const k2 = k1.clone();
=======
acquit:ignore:end

#### It clones a Kareem object

```javascript
var k1 = new Kareem();
k1.pre('cook', function() {});
k1.post('cook', function() {});

var k2 = k1.clone();
>>>>>>> main
assert.deepEqual(Array.from(k2._pres.keys()), ['cook']);
assert.deepEqual(Array.from(k2._posts.keys()), ['cook']);
```

## merge()

<<<<<<< HEAD
### It pulls hooks from another Kareem object

```javascript
const k1 = new Kareem();
const test1 = function() {};
k1.pre('cook', test1);
k1.post('cook', function() {});

const k2 = new Kareem();
const test2 = function() {};
k2.pre('cook', test2);
const k3 = k2.merge(k1);
=======
#### It pulls hooks from another Kareem object

```javascript
var k1 = new Kareem();
var test1 = function() {};
k1.pre('cook', test1);
k1.post('cook', function() {});

var k2 = new Kareem();
var test2 = function() {};
k2.pre('cook', test2);
var k3 = k2.merge(k1);
>>>>>>> main
assert.equal(k3._pres.get('cook').length, 2);
assert.equal(k3._pres.get('cook')[0].fn, test2);
assert.equal(k3._pres.get('cook')[1].fn, test1);
assert.equal(k3._posts.get('cook').length, 1);
```
